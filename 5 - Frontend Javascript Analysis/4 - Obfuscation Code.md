# JavaScript Obfuscation & Packed Code

## Summary

This session explains the concept of **JavaScript obfuscation**, its goals, common techniques, and how to approach analyzing obfuscated or packed JavaScript code. The video also introduces several **online tools** for deobfuscating and unpacking code. You’ll learn:

- The difference between **minification** and **obfuscation**
    
- Why obfuscation is used and how it complicates reverse engineering
    
- Examples of online obfuscators (e.g., `javascriptobfuscator.com`)
    
- Multiple **deobfuscation tools** and analysis strategies
    
- What **packed JavaScript** is and how to unpack it
    
- Preference for **dynamic analysis** over static analysis for obfuscated JS
    

---

## What is JavaScript Obfuscation?

Obfuscation is the process of making code **intentionally difficult to read and understand**, **without changing functionality**.

### Goals:

- Prevent reverse engineering or replication
    
- Protect intellectual property
    
- Slow down attackers or analysts
    

> [!note]  
> Obfuscation is **not a security mechanism**, but a form of **security through obscurity**—an additional layer in a defense stack.

---

## How Obfuscation Works

Typical techniques include:

- Renaming variables/functions to **nondescriptive names**
    
    ```js
    var PomodoroTimer = ...  // becomes:
    var a = ...
    ```
    
- **Restructuring control flow**
    
- **Adding dead code** (unused junk logic that wastes analysis time)
    

> [!warning]  
> Obfuscated code can make basic inspection infeasible, especially under exam or CTF time constraints.

---

## Comparing Minification vs. Obfuscation

|Feature|Minification|Obfuscation|
|---|---|---|
|Purpose|Improve performance|Hide logic / prevent reverse engineering|
|Code readability|Reduced|Deliberately confusing|
|Variable renaming|Sometimes|Aggressively renamed|
|Adds dead code|No|Often|
|Tool example|`terser`|`javascriptobfuscator.com`, `aaencode`|

---

## Obfuscation in Practice

### Online Obfuscation Demo

Tool: [https://javascriptobfuscator.com](https://javascriptobfuscator.com/)

Example:

```js
console.log("test");
```

Becomes a long, unreadable structure when deeply obfuscated.

- Turning off features like **code transposition**, **dead code insertion**, or **deep obfuscation** results in a smaller, slightly more readable output.
    
- You **won’t find "test"** in the output directly—it gets encoded or abstracted.
    

---

### AAEncode Example

Tool: [https://utf-8.jp/public/aaencode.html](https://utf-8.jp/public/aaencode.html)

- Converts code into JavaScript using **emoticons** (aaencode)
    
- Further increases complexity, especially when chained with other obfuscation methods
    
- In the example:
    
    - Obfuscated code → aaencoded → still executes properly
        
    - Output remains `test`
        

> [!tip]  
> Combining multiple obfuscation layers drastically increases time to reverse-engineer but can be identified and peeled back step-by-step.

---

## Strategy: Deobfuscation

### Static vs. Dynamic

- **Static analysis** of deeply obfuscated code is slow and tedious
    
- Prefer **dynamic analysis** using breakpoints and console inspection
    

> [!note]  
> Only reverse statically if required by scope (e.g., on a red team engagement or code review)

---

## Tools for Deobfuscation

|Tool / Website|Purpose|
|---|---|
|**[beautifier.io](https://beautifier.io/)**|Make obfuscated/minified code more readable|
|**[unminify.com](https://unminify.com/)**|Basic beautifier for minified JS|
|**[JSNice.org](http://www.jsnice.org/)**|Tries to guess original variable names|
|**[d4js](https://lelinhtinh.github.io/de4js/)**|Deobfuscator/unpacker with previews|
|**[jsconsole.com](https://jsconsole.com/)**|Safe JS execution for unknown code|

> [!tip]  
> Use **jsconsole.com** to test unfamiliar or suspicious code outside your local console.

---

## Working with Packed JavaScript

### What is Packed JS?

Packed JavaScript is:

- **Compressed + obfuscated**
    
- Wrapped in an `eval()` function
    
- Executes and **unpacks itself** at runtime
    

Common use cases:

- Older libraries or legacy tools
    
- Source code compression
    
- Lightweight obfuscation
    

---

### Identifying Packed Code

#### Example:

```js
eval(function(p,a,c,k,e,d){...})
```

This is a tell-tale pattern of a **JS packer**, often generated by:

- [https://jscompress.com](https://jscompress.com/)
    
- [https://jspacker.org](https://jspacker.org/)
    

---

### Unpacking Packed JS

Use online unpackers:

#### Tool: [https://lelinhtinh.github.io/de4js/](https://lelinhtinh.github.io/de4js/)

OR

#### Tool: [http://matthewfl.com/unpacker](http://matthewfl.com/unpacker)

```plaintext
1. Paste packed JS
2. Click "Unpack"
3. Retrieve the original readable code
```

> [!note]  
> Packed JS is a **legacy technique**, but may still appear in malware or old apps. Modern devs prefer minification using `terser`.

---

## Summary of Approach

1. **Beautify or unminify** the obfuscated script
    
2. **Identify eval() or encoding patterns**
    
3. Use **online tools** to unpack or "niceify"
    
4. Switch to **dynamic analysis** (breakpoints, console) to speed up understanding
    
5. Only reverse statically if **required**
    

---

## Key Takeaways

> [!tip]  
> Use **dynamic analysis first** when facing obfuscated code. It’s faster than static reverse engineering and exposes runtime behavior.

> [!warning]  
> Obfuscation often hides string values, control flow, or functions. Static inspection won’t easily reveal logic.

> [!note]  
> When encountering `eval(function(p,a,c,k,e,d){...})`, recognize it as a **packer pattern** and unpack it using `de4js` or `matthewfl.com`.
